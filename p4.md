Okay. Letâ€™s reset and build this **from zero**, no paper language, no assumptions.
Iâ€™ll explain **what each thing is**, **why it exists**, and **why the paper keeps talking about them**.

---

## 1ï¸âƒ£ What is MQTT?

### Simple meaning

**MQTT (Message Queuing Telemetry Transport)** is a **lightweight messaging protocol** designed for **small devices**, **slow networks**, and **IoT**.

Think of MQTT as:

> â€œWhatsApp for sensors and machines, but extremely lightweight.â€

---

### Why MQTT exists

Normal internet protocols (HTTP, REST):

* Too **heavy**
* Too many headers
* Too much bandwidth
* Too slow for tiny devices

IoT devices often have:

* Low CPU
* Low memory
* Poor network
* Battery constraints

ðŸ‘‰ MQTT was designed **specifically** for this environment.

---

### Core idea: Publishâ€“Subscribe (NOT clientâ€“server)

MQTT **does not** work like:

```
Client â†’ Server â†’ Response
```

It works like:

```
Publisher â†’ Broker â†’ Subscribers
```

#### Roles:

* **Publisher**: device sending data (sensor, camera, controller)
* **Subscriber**: device receiving data
* **Broker**: middleman (central server)

Example:

```
Temperature sensor â†’ Broker â†’ Mobile app
```

The sensor does **not** know who receives the data.

---

### Topics (very important)

Messages are sent to **topics**, which look like paths:

```
device/room1/temperature
factory/machineA/status
home/light/kitchen
```

Subscribers say:

```
â€œI want messages from device/+/temperatureâ€
```

This is **powerful** but also **dangerous** if not controlled.

---

## 2ï¸âƒ£ What is the MQTT Protocol (how it actually works)

MQTT is an **application-layer protocol** (Layer 7).

It runs on:

* **TCP**
* Default port **1883** (unencrypted)
* Port **8883** (TLS)

---

### MQTT message types (important)

Some key ones:

| Message    | Meaning        |
| ---------- | -------------- |
| CONNECT    | Start session  |
| CONNACK    | Broker accepts |
| PUBLISH    | Send data      |
| SUBSCRIBE  | Ask for topic  |
| PINGREQ    | KeepAlive ping |
| DISCONNECT | Close session  |

**Rule in MQTT**:

> You MUST send CONNECT before you send PUBLISH.

If you violate this â†’ protocol abuse / attack.

---

### KeepAlive (heartbeat)

When connecting, client says:

```
KeepAlive = 60 seconds
```

Meaning:

> â€œIf you donâ€™t hear from me for 60 seconds, assume Iâ€™m dead.â€

Clients send:

* PINGREQ
* or any message

This is used for **anomaly detection** later.

---

## 3ï¸âƒ£ Why MQTT is insecure by default

MQTT was designed for **trusted environments**.

Reality today:

* Internet-exposed brokers
* Weak configs
* No authentication
* No encryption

Problems:

* Anyone can **publish fake data**
* Anyone can **subscribe to sensitive topics**
* Flood attacks (DoS)
* Topic wildcard abuse (`#`, `+`)

Thatâ€™s why **security matters**.

---

## 4ï¸âƒ£ What is Edge Security?

### First: what is â€œthe edgeâ€?

**Edge = close to the devices**

Instead of:

```
IoT â†’ Internet â†’ Cloud â†’ Security
```

Edge security:

```
IoT â†’ Edge switch / gateway â†’ Security â†’ Broker
```

Examples of edge:

* IoT gateway
* Router
* Switch
* Smart NIC

---

### Edge security means:

> â€œDetect and block attacks **before** traffic reaches the broker or cloud.â€

Why this matters:

* Faster (microseconds)
* Less bandwidth waste
* Prevents overload
* Real-time control systems need this

---

## 5ï¸âƒ£ What is a Cloud-Based IDS?

### IDS = Intrusion Detection System

A **cloud-based IDS**:

* Collects traffic
* Sends it to cloud servers
* Analyzes it (often ML-based)
* Decides if itâ€™s malicious

Example flow:

```
IoT â†’ Broker â†’ Cloud IDS â†’ Alert
```

---

### Problems with cloud IDS (VERY important)

1. **Latency**

   * Hundreds of milliseconds
   * Too slow for IoT control

2. **Reaction delay**

   * Detection happens AFTER damage

3. **Bandwidth**

   * Raw traffic must be exported

4. **Not inline**

   * Often only alerts, doesnâ€™t block

Thatâ€™s why the paper says:

> Cloud IDS is unsuitable for real-time MQTT security

---

## 6ï¸âƒ£ What are CPU-Bound Firewalls?

### What this means

A **CPU-bound firewall**:

* Runs in software
* Uses general-purpose CPU
* Examples:

  * iptables
  * nftables
  * pf
  * software DPI firewalls

---

### Why they fail for MQTT

1. **Deep inspection is expensive**

   * MQTT is application-layer
   * Variable-length fields
   * Topic strings

2. **CPU bottleneck**

   * Thousands of IoT devices = too many packets
   * CPU cannot keep up at line rate

3. **Not protocol-aware**

   * Canâ€™t enforce:

     * â€œCONNECT before PUBLISHâ€
     * Topic-level ACLs
     * KeepAlive behavior

So they either:

* Miss attacks
* Or drop too much traffic

---

## 7ï¸âƒ£ Why the paper cares about all this (big picture)

The paperâ€™s logic is:

| Approach      | Problem                 |
| ------------- | ----------------------- |
| Cloud IDS     | Too slow                |
| CPU firewalls | Too weak / too slow     |
| L3/L4 SDN     | Doesnâ€™t understand MQTT |
| Broker ACLs   | After traffic arrives   |

ðŸ‘‰ Solution:

> Put **MQTT-aware security directly into the network edge**, running at **line rate**, using **P4 programmable switches**.

---

### Mental one-line summary

> MQTT is a lightweight IoT messaging protocol that is insecure by default. Traditional cloud IDS and CPU-based firewalls are either too slow or too weak to protect it in real time, so the paper proposes enforcing MQTT-aware security directly at the network edge.

---

Good â€” these **three terms are the CORE of the paper**.
If you understand them properly, the whole design will click.

Iâ€™ll explain each one in **plain language**, then **how MQTT uses it**, then **how attackers break it**, and finally **how the paper enforces it**.

---

# 1ï¸âƒ£ Session Validation

## What â€œsessionâ€ means (first principles)

A **session** is:

> A logical conversation between a client and a server with a defined start, rules, and end.

Example (human analogy):

* You **enter** a building â†’ show ID
* You **do work**
* You **leave**

If someone starts working **without entering**, thatâ€™s suspicious.

---

## Session in MQTT

In MQTT, a **valid session** looks like this:

```
CONNECT  â†’ session starts
PUBLISH / SUBSCRIBE / PINGREQ
DISCONNECT â†’ session ends
```

### Absolute rule:

> **PUBLISH is only legal AFTER CONNECT**

---

## What is Session Validation?

**Session validation** means:

> Checking whether a client is following the correct MQTT message order.

In simple terms:

* Did the client **CONNECT first**?
* Is the session currently **open**?
* Is the client allowed to send this message **right now**?

---

## Why session validation matters

### Attack example

An attacker can:

* Skip CONNECT
* Directly send PUBLISH packets
* Flood the broker

This:

* Wastes broker CPU
* Bypasses authentication
* Causes DoS

---

## How the paper enforces session validation

At the **edge switch**:

* Each client has a **1-bit state**:

  ```
  session_open = 0 or 1
  ```

### Logic:

* If message = CONNECT â†’ set session_open = 1
* If message = PUBLISH and session_open = 0 â†’ **DROP**

Thatâ€™s it.
Simple. Fast. Effective.

ðŸ“Œ In the paper this is called:

> **â€œCONNECT-before-PUBLISH enforcementâ€**

---

### Why this is powerful

* Happens **before broker**
* Happens at **line rate**
* Broker never sees invalid traffic

---

# 2ï¸âƒ£ Topic-Based Authorization

## First: what is a â€œtopicâ€?

A **topic** is the address of the message:

```
device/sensor/temp
factory/machineA/status
home/light/kitchen
```

Topics are **hierarchical** (like folders).

---

## What is Topic-Based Authorization?

It means:

> Deciding **who is allowed to publish to which topics**

Example policy:

* Sensor A â†’ `device/sensor/*`
* Controller â†’ `device/control/*`
* No one â†’ `system/admin/*`

---

## Why topic authorization is critical in MQTT

### Without it:

Any device can publish to:

```
factory/machineA/command
```

Result:

* Fake commands
* Safety issues
* Physical damage

---

## How attackers exploit topics

1. **Wildcard abuse**

   ```
   #
   +
   ```
2. Publishing to **unauthorized namespaces**
3. Impersonating other devices

---

## How the paper enforces topic-based authorization

This is very clever ðŸ‘‡

### Constraint:

P4 switches have:

* Limited memory
* No string processing

### Solution:

* Extract **only the first 16 bytes** of the topic
* Match it using **ternary ACL (TCAM)**

Example:

```
device/sensor/temperature
```

First 16 bytes:

```
device/sensor/
```

### Rule:

> If topic prefix matches allowed pattern â†’ allow
> Else â†’ drop

---

### Why prefix matching is enough

* MQTT topics are hierarchical
* Most security decisions depend on **namespace**, not full string

---

### Key idea

> **Authorization is enforced in the network**, not the broker.

---

# 3ï¸âƒ£ Behavioral Anomaly Detection

## What â€œbehavioral anomalyâ€ means

Instead of checking:

* IP
* Port
* Signature

You check:

> â€œIs this client behaving normally?â€

---

## In MQTT, â€œnormal behaviorâ€ is defined by:

* KeepAlive timing
* Message rate
* Message size
* Message order

---

## Why behavioral detection is needed

Some attacks are:

* Protocol-valid
* Authenticated
* Hard to signature-match

Example:

* Slow DoS
* Oversized payload abuse
* KeepAlive manipulation

---

## The paper uses **lightweight heuristics** (not ML)

Why?

* ML is slow
* Needs CPU
* Not suitable for data plane

---

## Anomaly #1: KeepAlive Violation

### Normal behavior

Client says:

```
KeepAlive = 60 seconds
```

It must send something every â‰¤60 seconds.

---

### Anomalous behavior

* Client stays silent too long
* Or sends bursts after silence

This indicates:

* Broken client
* Malicious behavior
* Zombie device

---

### Detection logic (simple)

```
If time_since_last_ping > Î³ Ã— KeepAlive
â†’ anomaly
```

Where:

* Î³ â‰ˆ 1.5 (tolerance)

---

### What the system does

* DOES NOT drop immediately
* **Clones packet to CPU**
* Records metadata
* Allows diagnosis

This avoids false positives.

---

## Anomaly #2: Remaining Length Abuse

### What is Remaining Length?

MQTT field that says:

> â€œHow big is the message payload?â€

Encoded in **1â€“4 bytes**.

---

### Why this is dangerous

* Large Remaining Length = memory allocation
* Multiple bytes = DoS vector

---

### Detection

If:

```
Remaining Length â‰¥ threshold
OR encoding uses â‰¥3 bytes
```

â†’ Flag as anomaly

---

## Key idea: detect, donâ€™t overreact

The paper:

* **Detects anomalies**
* **Clones to control plane**
* Does NOT blindly drop

This is smarter than classic firewalls.

---

# Big Picture (connect all three)

| Mechanism            | Protects Against       |
| -------------------- | ---------------------- |
| Session validation   | Protocol abuse         |
| Topic authorization  | Unauthorized control   |
| Behavioral detection | Stealth / slow attacks |

All done:

* At the **edge**
* In the **data plane**
* At **line rate**
* Without CPU bottlenecks

---

## One-line mental model

> Session validation checks *order*, topic authorization checks *permission*, and behavioral anomaly detection checks *how the client behaves over time*.

---

Good â€” now weâ€™re at the **engine of the whole paper**.
These terms sound scary because they mix **network hardware + programming + protocols**, but the ideas are actually very logical.

Iâ€™ll go **step by step**, from intuition â†’ mechanism â†’ why the paper uses it.

---

# 1ï¸âƒ£ What is P4?

## First: what problem P4 solves

Traditional network devices (switches/routers):

* Fixed behavior
* You **cannot change how packets are processed**
* They only understand:

  * Ethernet
  * IP
  * TCP/UDP

They **do NOT understand MQTT, HTTP, DNS**, etc.

---

## What P4 is (plain English)

**P4 = Programming language for network packet processing**

More precisely:

> P4 lets you program **how a switch parses, inspects, and forwards packets**.

Think of it as:

> â€œWriting code that runs *inside* the network switch.â€

---

## What P4 can do

With P4, you can:

* Define **new headers** (like MQTT)
* Parse **application-layer fields**
* Keep **state** (registers, counters)
* Enforce policies at **line rate**

Without sending packets to CPU.

---

## Where P4 runs

P4 programs run on:

* Programmable switches (ASICs like Tofino)
* Smart NICs
* Software switches (BMv2 â€“ used in the paper)

---

## Key mental model

| Traditional firewall | P4                      |
| -------------------- | ----------------------- |
| CPU-based            | Hardware pipeline       |
| Slow                 | Line rate               |
| Limited inspection   | Custom protocol parsing |
| Reactive             | Inline enforcement      |

---

# 2ï¸âƒ£ What is a P4-Based Data Plane Enforcement Scheme?

Letâ€™s break that monster phrase.

---

## Data plane vs Control plane

### Data plane

* Handles **every packet**
* Must be **extremely fast**
* No loops, no heavy logic

### Control plane

* Slow
* Configures rules
* Collects logs

---

## P4-based data plane enforcement scheme means:

> â€œSecurity rules are enforced directly in the packet-processing pipeline of the switch, not in software or cloud.â€

In this paper:

* MQTT rules are enforced **as packets flow**
* Decisions are made **before broker**
* No round trips
* No CPU involvement

---

## Enforcement means

The switch decides:

* Forward
* Drop
* Clone (copy to CPU)

Based on:

* MQTT type
* Session state
* Topic prefix
* Rate
* Behavior

---

## Why this is powerful

* Microsecond latency
* Scales to millions of packets/sec
* Stops attacks **before damage**

---

# 3ï¸âƒ£ What does â€œProtocol-Awareâ€ mean?

## Normal network devices are protocol-blind

A normal switch sees:

```
IP src, IP dst, TCP port
```

It does NOT know:

* Is this CONNECT or PUBLISH?
* Is this topic allowed?
* Is this MQTT malformed?

---

## Protocol-aware means

> The network understands the **semantics** of the application protocol.

For MQTT-aware:

* Knows message types
* Knows field meanings
* Knows protocol rules

---

## Example difference

### Protocol-unaware firewall:

```
ALLOW tcp port 1883
```

### Protocol-aware enforcement:

```
ALLOW PUBLISH
ONLY IF
- CONNECT happened
- Topic prefix is allowed
- Rate is acceptable
```

Thatâ€™s a **huge difference**.

---

## Why the paper emphasizes this

MQTT attacks:

* Look valid at TCP level
* Are malicious at MQTT level

Only protocol-aware systems can stop them.

---

# 4ï¸âƒ£ What is â€œParser-Safe MQTTâ€?

This is very important and very subtle.

---

## What is parsing?

Parsing = reading packet bytes and interpreting fields.

Example:

```
Byte 1 â†’ message type
Byte 2 â†’ flags
Next bytes â†’ Remaining Length
```

---

## Why parsing MQTT is dangerous

MQTT has:

* Variable-length fields
* Optional fields
* Length-encoded values

Attackers exploit this by:

* Sending malformed packets
* Triggering parser crashes
* Causing infinite loops
* Bypassing checks

---

## Parser-safe means

> Parsing logic that **cannot crash**, **cannot stall**, and **cannot be tricked** by malformed packets.

---

## How the paper makes MQTT parsing safe

### 1ï¸âƒ£ Skip IPv4/TCP options safely

Instead of assuming fixed headers:

* Compute option length
* Advance pointer
* Avoid exceptions

---

### 2ï¸âƒ£ Fragment filtering

Only parse:

```
fragOffset = 0
```

Why?

* MQTT headers split across fragments = evasion

---

### 3ï¸âƒ£ Bounded extraction

Instead of parsing full topic string:

* Extract **only first 16 bytes**
* Skip the rest

This prevents:

* Memory exhaustion
* Parser complexity

---

### 4ï¸âƒ£ Remaining Length screening

If Remaining Length encoding uses:

* â‰¥3 bytes

â†’ Flag as suspicious

---

## Why this matters in hardware

P4 parsers:

* Are finite-state machines
* Cannot handle unbounded loops
* Must be predictable

Parser-safe design ensures:

* Line-rate
* No undefined behavior
* Hardware compatibility

---

# 5ï¸âƒ£ Putting it all together (big picture)

### The paper builds:

* A **protocol-aware** system
* Using **P4**
* Running in the **data plane**
* With **parser-safe MQTT extraction**

### Result:

* MQTT security enforced **inside the network**
* No CPU bottleneck
* No cloud latency
* Real-time protection

---

## One-sentence intuition

> P4 lets the network itself understand MQTT, safely parse it, and enforce security rules at hardware speed before traffic ever reaches the broker.

---

Good â€” now weâ€™re at the **engine of the whole paper**.
These terms sound scary because they mix **network hardware + programming + protocols**, but the ideas are actually very logical.

Iâ€™ll go **step by step**, from intuition â†’ mechanism â†’ why the paper uses it.

---

# 1ï¸âƒ£ What is P4?

## First: what problem P4 solves

Traditional network devices (switches/routers):

* Fixed behavior
* You **cannot change how packets are processed**
* They only understand:

  * Ethernet
  * IP
  * TCP/UDP

They **do NOT understand MQTT, HTTP, DNS**, etc.

---

## What P4 is (plain English)

**P4 = Programming language for network packet processing**

More precisely:

> P4 lets you program **how a switch parses, inspects, and forwards packets**.

Think of it as:

> â€œWriting code that runs *inside* the network switch.â€

---

## What P4 can do

With P4, you can:

* Define **new headers** (like MQTT)
* Parse **application-layer fields**
* Keep **state** (registers, counters)
* Enforce policies at **line rate**

Without sending packets to CPU.

---

## Where P4 runs

P4 programs run on:

* Programmable switches (ASICs like Tofino)
* Smart NICs
* Software switches (BMv2 â€“ used in the paper)

---

## Key mental model

| Traditional firewall | P4                      |
| -------------------- | ----------------------- |
| CPU-based            | Hardware pipeline       |
| Slow                 | Line rate               |
| Limited inspection   | Custom protocol parsing |
| Reactive             | Inline enforcement      |

---

# 2ï¸âƒ£ What is a P4-Based Data Plane Enforcement Scheme?

Letâ€™s break that monster phrase.

---

## Data plane vs Control plane

### Data plane

* Handles **every packet**
* Must be **extremely fast**
* No loops, no heavy logic

### Control plane

* Slow
* Configures rules
* Collects logs

---

## P4-based data plane enforcement scheme means:

> â€œSecurity rules are enforced directly in the packet-processing pipeline of the switch, not in software or cloud.â€

In this paper:

* MQTT rules are enforced **as packets flow**
* Decisions are made **before broker**
* No round trips
* No CPU involvement

---

## Enforcement means

The switch decides:

* Forward
* Drop
* Clone (copy to CPU)

Based on:

* MQTT type
* Session state
* Topic prefix
* Rate
* Behavior

---

## Why this is powerful

* Microsecond latency
* Scales to millions of packets/sec
* Stops attacks **before damage**

---

# 3ï¸âƒ£ What does â€œProtocol-Awareâ€ mean?

## Normal network devices are protocol-blind

A normal switch sees:

```
IP src, IP dst, TCP port
```

It does NOT know:

* Is this CONNECT or PUBLISH?
* Is this topic allowed?
* Is this MQTT malformed?

---

## Protocol-aware means

> The network understands the **semantics** of the application protocol.

For MQTT-aware:

* Knows message types
* Knows field meanings
* Knows protocol rules

---

## Example difference

### Protocol-unaware firewall:

```
ALLOW tcp port 1883
```

### Protocol-aware enforcement:

```
ALLOW PUBLISH
ONLY IF
- CONNECT happened
- Topic prefix is allowed
- Rate is acceptable
```

Thatâ€™s a **huge difference**.

---

## Why the paper emphasizes this

MQTT attacks:

* Look valid at TCP level
* Are malicious at MQTT level

Only protocol-aware systems can stop them.

---

# 4ï¸âƒ£ What is â€œParser-Safe MQTTâ€?

This is very important and very subtle.

---

## What is parsing?

Parsing = reading packet bytes and interpreting fields.

Example:

```
Byte 1 â†’ message type
Byte 2 â†’ flags
Next bytes â†’ Remaining Length
```

---

## Why parsing MQTT is dangerous

MQTT has:

* Variable-length fields
* Optional fields
* Length-encoded values

Attackers exploit this by:

* Sending malformed packets
* Triggering parser crashes
* Causing infinite loops
* Bypassing checks

---

## Parser-safe means

> Parsing logic that **cannot crash**, **cannot stall**, and **cannot be tricked** by malformed packets.

---

## How the paper makes MQTT parsing safe

### 1ï¸âƒ£ Skip IPv4/TCP options safely

Instead of assuming fixed headers:

* Compute option length
* Advance pointer
* Avoid exceptions

---

### 2ï¸âƒ£ Fragment filtering

Only parse:

```
fragOffset = 0
```

Why?

* MQTT headers split across fragments = evasion

---

### 3ï¸âƒ£ Bounded extraction

Instead of parsing full topic string:

* Extract **only first 16 bytes**
* Skip the rest

This prevents:

* Memory exhaustion
* Parser complexity

---

### 4ï¸âƒ£ Remaining Length screening

If Remaining Length encoding uses:

* â‰¥3 bytes

â†’ Flag as suspicious

---

## Why this matters in hardware

P4 parsers:

* Are finite-state machines
* Cannot handle unbounded loops
* Must be predictable

Parser-safe design ensures:

* Line-rate
* No undefined behavior
* Hardware compatibility

---

# 5ï¸âƒ£ Putting it all together (big picture)

### The paper builds:

* A **protocol-aware** system
* Using **P4**
* Running in the **data plane**
* With **parser-safe MQTT extraction**

### Result:

* MQTT security enforced **inside the network**
* No CPU bottleneck
* No cloud latency
* Real-time protection

---

## One-sentence intuition

> P4 lets the network itself understand MQTT, safely parse it, and enforce security rules at hardware speed before traffic ever reaches the broker.

---

Alright. I hear you.
Iâ€™m going to **slow this down**, **clean this up**, and explain **each term carefully**, with **zero buzzwords**, **clear intuition**, and **concrete examples**.
No skipping steps. No â€œpaper-styleâ€ fluff.

Read this **in order** â€” these concepts build on each other.

---

# 1ï¸âƒ£ Soft Cap Enforcement (a.k.a. Soft Limit)

## First: what does â€œcapâ€ mean?

A **cap** is a **maximum allowed amount**.

Example in real life:

* Free plan: **10,000 API calls/day**
* After that â†’ blocked

---

## What is a *soft* cap (vs hard cap)?

### Hard cap

* Absolute cutoff
* One violation â†’ immediate permanent block

### Soft cap

* Tolerant
* Allows some behavior
* Starts dropping or throttling **after a threshold**

---

## Soft cap in THIS paper

Here:

> **Soft cap = maximum number of PUBLISH messages per client**

Example:

```
pub_soft_limit = 20,000
```

Meaning:

* First 20,000 PUBLISH messages â†’ allowed
* 20,001 onward â†’ dropped

---

## Why this is needed

Even a **legitimate client** can:

* Malfunction
* Loop
* Get compromised

Without a soft cap:

* Broker memory explodes
* CPU spikes
* Other clients suffer

---

## Why not just rate limit?

Because:

* A client can send **slow but infinite** traffic
* Rate looks fine
* Total volume is still dangerous

Soft cap protects against **long-term flooding**.

---

## How it works internally (simple)

For each client:

```
publish_counter += 1
if publish_counter > soft_cap:
    DROP
```

No time, no ML, no CPU.
Just counting.

---

# 2ï¸âƒ£ KeepAlive (MQTT concept)

## What KeepAlive is (plain English)

KeepAlive is a **promise** made by the client.

Client says:

```
â€œI will send you at least one message every X secondsâ€
```

Example:

```
KeepAlive = 60 seconds
```

---

## Why KeepAlive exists

TCP alone canâ€™t detect:

* Dead devices
* Frozen clients
* Network blackholes

KeepAlive solves:

* â€œIs the client still alive?â€

---

## How it works

Client must send:

* Any MQTT packet **or**
* PINGREQ

Before `KeepAlive` expires.

---

## Why KeepAlive matters for security

Abnormal KeepAlive behavior indicates:

* Broken firmware
* Zombie bot
* Slow DoS
* Stealth attack

---

## What the paper does with KeepAlive

It **tracks time gaps** between messages.

If:

```
time_since_last_message > Î³ Ã— KeepAlive
```

â†’ **behavioral anomaly**

Important:

* It does NOT immediately drop
* It flags & clones for analysis

---

# 3ï¸âƒ£ Remaining Length Screening

This one is CRITICAL and often misunderstood.

---

## What is â€œRemaining Lengthâ€ in MQTT?

It is a field that says:

> â€œHow many bytes are left in this MQTT messageâ€

Includes:

* Topic
* Payload
* Properties

---

## Why Remaining Length is dangerous

Remaining Length is:

* Variable-length encoded (1â€“4 bytes)
* Can represent **very large values**

Attackers exploit this to:

* Force memory allocation
* Crash brokers
* Cause DoS

---

## Example attack

Send packet saying:

```
Remaining Length = 200,000 bytes
```

Broker:

* Allocates memory
* Waits for payload
* Gets overwhelmed

---

## What â€œscreeningâ€ means

Screening â‰  blocking everything
Screening = **checking for suspicious values**

---

## What the paper checks

Two things:

### 1ï¸âƒ£ Encoding length

If Remaining Length uses **â‰¥3 bytes**
â†’ suspicious

Why?

* Normal IoT messages are small

---

### 2ï¸âƒ£ Absolute size

If:

```
Remaining Length â‰¥ threshold (e.g. 16 KB, 128 KB)
```

â†’ suspicious

---

## What happens when detected?

* Packet is **cloned to CPU**
* Metadata recorded
* Original packet may still pass

This avoids false positives.

---

# 4ï¸âƒ£ Stateful Primitives

This is NOT scary.
It just means **memory inside the switch**.

---

## â€œStatefulâ€ means

> The device remembers past packets.

Opposite of:

* Stateless firewall (each packet alone)

---

## P4 stateful primitives used

### Registers

* Store values per client
* Example:

  * session_open
  * publish_counter
  * last_keepalive_time

---

### Counters

* Count packets
* Used for statistics & enforcement

---

### Meters

* Measure packet rate
* Enforce speed limits

---

## Why state is essential

Without state:

* No session validation
* No rate limiting
* No anomaly detection

State = memory = intelligence.

---

# 5ï¸âƒ£ BMv2 / Mininet / BMv2 Testbed

Letâ€™s demystify this.

---

## BMv2 (Behavioral Model v2)

BMv2 is:

> A **software implementation** of a P4 switch.

Used for:

* Testing
* Research
* Debugging

It behaves like hardware, but runs on CPU.

---

## Mininet

Mininet is:

> A network emulator

It lets you create:

* Switches
* Hosts
* Links

All on one machine.

---

## BMv2 + Mininet testbed means

They created:

```
Virtual IoT network
â†“
BMv2 switch (running P4)
â†“
Virtual MQTT broker
```

This lets them:

* Test behavior
* Measure performance
* Validate correctness

---

## Why not real hardware?

Because:

* ASICs are expensive
* Not always available
* Research starts in simulation

---

# 6ï¸âƒ£ KPPS (Kilo Packets Per Second)

## What it means

```
1 kpps = 1,000 packets per second
10 kpps = 10,000 packets per second
```

---

## Why packets/sec matters

IoT traffic:

* Many small packets
* Rate matters more than bandwidth

10,000 tiny MQTT packets/sec can kill a broker.

---

## In the paper

They test up to:

```
16 kpps
```

Thatâ€™s realistic for IoT gateways.

---

# 7ï¸âƒ£ Line Rate (not â€œlive rateâ€)

## Line rate means

> Processing packets **as fast as the link allows**, with **no slowdown**

Example:

* 1 Gbps link
* Switch processes packets at full 1 Gbps

No buffering.
No CPU delays.

---

## Why line rate is important

If security:

* Slows traffic
* Adds latency

It breaks real-time IoT systems.

P4 is designed for **line-rate enforcement**.

---

# 8ï¸âƒ£ Programmable Data Plane

## Data plane (recap)

Handles:

* Every packet
* Must be fast

---

## Programmable data plane means

> You can **change what the network does with packets**, not just routing.

Instead of:

```
if dst_ip == X â†’ forward
```

You can do:

```
if MQTT.PUBLISH and topic not allowed â†’ drop
```

That is revolutionary.

---

## Why this is different from firewalls

Firewalls:

* CPU-based
* Slow
* Reactive

Programmable data plane:

* Inline
* Hardware-speed
* Deterministic

---

# 9ï¸âƒ£ P4 Hardware

## What P4 hardware is

Physical devices that run P4:

* ASIC switches (Tofino)
* SmartNICs
* FPGA-based NICs

---

## What makes them special

* Nanosecond processing
* Massive parallelism
* On-chip memory
* TCAM for ACLs

---

## Why the paper cares

Because their design:

* Uses bounded parsing
* Uses simple state
* Fits real hardware constraints

Meaning:

> This is not just theory â€” it can run in production.

---

# Final mental map (IMPORTANT)

```
P4 hardware
 â†“
Programmable data plane
 â†“
Stateful primitives
 â†“
Header extraction
 â†“
Session validation
 â†“
Topic authorization
 â†“
Soft cap enforcement
 â†“
KeepAlive & Remaining Length screening
 â†“
Line-rate MQTT security
```

---

